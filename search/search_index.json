{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Online Collection of FAANG Interview Questions & Solutions What is this website? Contents from this website used to be my personal notes. I got tired of going back and forth between technical interview questions and solutions for FAANG companies so I decided to put solutions together for most commonly asked interview questions. Most of the questions and solutions are from Leetcode or Leetcode discuss. This is an open source project. Please feel free to contribute by making a Pull Request HERE Start Practicing Amazon Online Assessment Questions Disclaimer: This website is meant to be used as an additional study material for technical interviews, and some of the solutions might not have the best performance. I recommend running code on Leetcode to come up with your own solution.","title":"Intro"},{"location":"#online-collection-of-faang-interview-questions-solutions","text":"","title":"Online Collection of FAANG Interview Questions &amp; Solutions"},{"location":"#what-is-this-website","text":"Contents from this website used to be my personal notes. I got tired of going back and forth between technical interview questions and solutions for FAANG companies so I decided to put solutions together for most commonly asked interview questions. Most of the questions and solutions are from Leetcode or Leetcode discuss. This is an open source project. Please feel free to contribute by making a Pull Request HERE","title":"What is this website?"},{"location":"#start-practicing-amazon-online-assessment-questions","text":"Disclaimer: This website is meant to be used as an additional study material for technical interviews, and some of the solutions might not have the best performance. I recommend running code on Leetcode to come up with your own solution.","title":"Start Practicing Amazon Online Assessment Questions"},{"location":"amazon/","text":"Top N Competitors/Buzzwords Zombie in Matrix aka Min hours to send file to all available serversp Critical Routers Product Suggestions Number of Clusters Solution class Solution: def numIslands(self, grid: List[List[str]]) -> int: count=0 #to count number of islands for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j]=='1': self.dfs(grid, i, j) return count def dfs(self, grid, i, j): #skip the dfs check if the current element is water or previosuly marked land if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]!='1': return #mark this newly visited land element grid[i][j]='0' #check all the adjacent elements to find land self.dfs(grid, i+1, j) self.dfs(grid, i-1, j) self.dfs(grid, i, j+1) self.dfs(grid, i, j-1) Reorder Data in Log Files Solution class Solution(object): def reorderLogFiles(self, logs): \"\"\" :type logs: List[str] :rtype: List[str] \"\"\" let_logs = [] dig_logs = [] for log in logs: log_key, log_val = log.split(\" \", 1) if log_val[0].isalpha(): let_logs.append(log_val + \" \" + log_key) else: dig_logs.append(log) let_logs.sort() let_logs_sorted = [] for let_log in let_logs: log = let_log.split(\" \") log = log[-1] + \" \" + \" \".join(log[:-1]) let_logs_sorted.append(log) return let_logs_sorted + dig_logs Optimal Utilization Min Cost to Connect ropes/ Min Time to Merge Files Solution import unittest import heapq def solution(ropes): if len(ropes) < 2: return 0 heapq.heapify(ropes) res = 0 while len(ropes) > 1: sum = heapq.heappop(ropes) + heapq.heappop(ropes) res += sum heapq.heappush(ropes, sum) return res Treasure Island / Min Distance to Remove the Obstacle (BFS) Solution def solution(matrix): if (not matrix) or (not matrix[0]): return -1 # store the index of matrix and steps in queue queue = deque() queue.append([0, 0, 0]) while queue: i, j, steps = queue.popleft() # if the treasure island is found, return the steps if matrix[i][j] == 'X': return steps # mark visited index matrix[i][j] = 'D' # check all the adjacent indexes for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 'D'): queue.append([x, y, steps+1]) # if the treasure island is not found, return -1 return -1 Treasure Island II Find Pair With Given Sum Solution class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" d = {} for i, n in enumerate(nums): val = target - n if val in d: return d[val], i d[n] = i Copy List with Random Pointer Merge Two Sorted Lists Solution class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode: if not l1 and not l2: return None if not l1 and l2: return l2 if not l2 and l1: return l1 if l1.val <= l2.val: l3 = ListNode(l1.val) l1 = l1.next else: l3 = ListNode(l2.val) l2 = l2.next head = l3 while l1 and l2: if l1.val <= l2.val: l3.next = l1 l1 = l1.next else: l3.next = l2 l2 = l2.next l3 = l3.next if l1: l3.next = l1 else: l3.next = l2 return head Subtree of Another Tree Solution # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def isSubtree(self, s, t): \"\"\" :type s: TreeNode :type t: TreeNode :rtype: bool \"\"\" if s and not t: return True if not s and t: return False if self.isSameTree(s,t): return True return (self.isSubtree(s.left, t) or self.isSubtree(s.right, t)) def isSameTree(self, s, t): if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return self.isSameTree(s.left, t.left) and self.isSameTree(s.right, t.right) Search a 2D Matrix II Solution class Solution(object): def searchMatrix(self, matrix, target): \"\"\" :type matrix: List[List[int]] :type target: int :rtype: bool \"\"\" if not matrix: return False row = 0 col = len(matrix[0]) -1 while row < len(matrix) and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 elif matrix[row][col] < target: row += 1 return False Critical Connections Favorite Genres Two Sum - Unique Pairs Spiral Matrix Count substrings with exactly K distinct chars Max Of Min Altitudes Longest Palindromic Substring Substrings of size K with K distinct chars Most Common Word Solution class Solution(object): def mostCommonWord(self, paragraph, banned): \"\"\" :type paragraph: str :type banned: List[str] :rtype: str \"\"\" for c in paragraph: if c in \"!?',;.\": paragraph = paragraph.replace(c, \" \") words = [word for word in paragraph.lower().split()] d = {} for word in words: if word not in banned: if word in d: d[word] += 1 else: d[word] = 1 d = sorted(d, key=(lambda key:d[key]), reverse=True) return (d[0]) K Closest Points to Origin Solution class Solution(object): def kClosest(self, points, K): import math, itertools \"\"\" :type points: List[List[int]] :type K: int :rtype: List[List[int]] \"\"\" d = {} for x,y in points: distance = math.sqrt(x**2 + y**2) d[(x,y)] = distance sorted_d = sorted(d.items(), key=lambda x: x[1]) result = [[x,y] for x,y in (dict(itertools.islice(sorted_d, K)))] return result Generate Parentheses Min Cost to Connect All Nodes (a.k.a. Min Cost to Add New Roads) Min Cost to Repair Edges (MST) Prison Cells After N Days Partition Labels Subtree with Maximum Average","title":"Amazon"},{"location":"amazon/#top-n-competitorsbuzzwords","text":"","title":" Top N Competitors/Buzzwords "},{"location":"amazon/#zombie-in-matrix-aka-min-hours-to-send-file-to-all-available-serversp","text":"","title":" Zombie in Matrix aka Min hours to send file to all available serversp "},{"location":"amazon/#critical-routers","text":"","title":" Critical Routers "},{"location":"amazon/#product-suggestions","text":"","title":" Product Suggestions  "},{"location":"amazon/#number-of-clusters","text":"Solution class Solution: def numIslands(self, grid: List[List[str]]) -> int: count=0 #to count number of islands for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j]=='1': self.dfs(grid, i, j) return count def dfs(self, grid, i, j): #skip the dfs check if the current element is water or previosuly marked land if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]!='1': return #mark this newly visited land element grid[i][j]='0' #check all the adjacent elements to find land self.dfs(grid, i+1, j) self.dfs(grid, i-1, j) self.dfs(grid, i, j+1) self.dfs(grid, i, j-1)","title":" Number of Clusters "},{"location":"amazon/#reorder-data-in-log-files","text":"Solution class Solution(object): def reorderLogFiles(self, logs): \"\"\" :type logs: List[str] :rtype: List[str] \"\"\" let_logs = [] dig_logs = [] for log in logs: log_key, log_val = log.split(\" \", 1) if log_val[0].isalpha(): let_logs.append(log_val + \" \" + log_key) else: dig_logs.append(log) let_logs.sort() let_logs_sorted = [] for let_log in let_logs: log = let_log.split(\" \") log = log[-1] + \" \" + \" \".join(log[:-1]) let_logs_sorted.append(log) return let_logs_sorted + dig_logs","title":" Reorder Data in Log Files "},{"location":"amazon/#optimal-utilization","text":"","title":" Optimal Utilization "},{"location":"amazon/#min-cost-to-connect-ropes-min-time-to-merge-files","text":"Solution import unittest import heapq def solution(ropes): if len(ropes) < 2: return 0 heapq.heapify(ropes) res = 0 while len(ropes) > 1: sum = heapq.heappop(ropes) + heapq.heappop(ropes) res += sum heapq.heappush(ropes, sum) return res","title":" Min Cost to Connect ropes/ Min Time to Merge Files "},{"location":"amazon/#treasure-island-min-distance-to-remove-the-obstacle-bfs","text":"Solution def solution(matrix): if (not matrix) or (not matrix[0]): return -1 # store the index of matrix and steps in queue queue = deque() queue.append([0, 0, 0]) while queue: i, j, steps = queue.popleft() # if the treasure island is found, return the steps if matrix[i][j] == 'X': return steps # mark visited index matrix[i][j] = 'D' # check all the adjacent indexes for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if (0 <= x < len(matrix)) and (0 <= y < len(matrix[0])) and (matrix[x][y] != 'D'): queue.append([x, y, steps+1]) # if the treasure island is not found, return -1 return -1","title":" Treasure Island / Min Distance to Remove the Obstacle (BFS) "},{"location":"amazon/#treasure-island-ii","text":"","title":" Treasure Island II "},{"location":"amazon/#find-pair-with-given-sum","text":"Solution class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" d = {} for i, n in enumerate(nums): val = target - n if val in d: return d[val], i d[n] = i","title":" Find Pair With Given Sum "},{"location":"amazon/#copy-list-with-random-pointer","text":"","title":" Copy List with Random Pointer "},{"location":"amazon/#merge-two-sorted-lists","text":"Solution class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode: if not l1 and not l2: return None if not l1 and l2: return l2 if not l2 and l1: return l1 if l1.val <= l2.val: l3 = ListNode(l1.val) l1 = l1.next else: l3 = ListNode(l2.val) l2 = l2.next head = l3 while l1 and l2: if l1.val <= l2.val: l3.next = l1 l1 = l1.next else: l3.next = l2 l2 = l2.next l3 = l3.next if l1: l3.next = l1 else: l3.next = l2 return head","title":" Merge Two Sorted Lists "},{"location":"amazon/#subtree-of-another-tree","text":"Solution # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def isSubtree(self, s, t): \"\"\" :type s: TreeNode :type t: TreeNode :rtype: bool \"\"\" if s and not t: return True if not s and t: return False if self.isSameTree(s,t): return True return (self.isSubtree(s.left, t) or self.isSubtree(s.right, t)) def isSameTree(self, s, t): if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return self.isSameTree(s.left, t.left) and self.isSameTree(s.right, t.right)","title":" Subtree of Another Tree "},{"location":"amazon/#search-a-2d-matrix-ii","text":"Solution class Solution(object): def searchMatrix(self, matrix, target): \"\"\" :type matrix: List[List[int]] :type target: int :rtype: bool \"\"\" if not matrix: return False row = 0 col = len(matrix[0]) -1 while row < len(matrix) and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 elif matrix[row][col] < target: row += 1 return False","title":" Search a 2D Matrix II "},{"location":"amazon/#critical-connections","text":"","title":" Critical Connections "},{"location":"amazon/#favorite-genres","text":"","title":" Favorite Genres "},{"location":"amazon/#two-sum-unique-pairs","text":"","title":" Two Sum - Unique Pairs "},{"location":"amazon/#spiral-matrix","text":"","title":" Spiral Matrix "},{"location":"amazon/#count-substrings-with-exactly-k-distinct-chars","text":"","title":" Count substrings with exactly K distinct chars "},{"location":"amazon/#max-of-min-altitudes","text":"","title":" Max Of Min Altitudes "},{"location":"amazon/#longest-palindromic-substring","text":"","title":" Longest Palindromic Substring "},{"location":"amazon/#substrings-of-size-k-with-k-distinct-chars","text":"","title":" Substrings of size K with K distinct chars "},{"location":"amazon/#most-common-word","text":"Solution class Solution(object): def mostCommonWord(self, paragraph, banned): \"\"\" :type paragraph: str :type banned: List[str] :rtype: str \"\"\" for c in paragraph: if c in \"!?',;.\": paragraph = paragraph.replace(c, \" \") words = [word for word in paragraph.lower().split()] d = {} for word in words: if word not in banned: if word in d: d[word] += 1 else: d[word] = 1 d = sorted(d, key=(lambda key:d[key]), reverse=True) return (d[0])","title":"  Most Common Word "},{"location":"amazon/#k-closest-points-to-origin","text":"Solution class Solution(object): def kClosest(self, points, K): import math, itertools \"\"\" :type points: List[List[int]] :type K: int :rtype: List[List[int]] \"\"\" d = {} for x,y in points: distance = math.sqrt(x**2 + y**2) d[(x,y)] = distance sorted_d = sorted(d.items(), key=lambda x: x[1]) result = [[x,y] for x,y in (dict(itertools.islice(sorted_d, K)))] return result","title":" K Closest Points to Origin "},{"location":"amazon/#generate-parentheses","text":"","title":" Generate Parentheses "},{"location":"amazon/#min-cost-to-connect-all-nodes-aka-min-cost-to-add-new-roads","text":"","title":" Min Cost to Connect All Nodes (a.k.a. Min Cost to Add New Roads) "},{"location":"amazon/#min-cost-to-repair-edges-mst","text":"","title":" Min Cost to Repair Edges (MST) "},{"location":"amazon/#prison-cells-after-n-days","text":"","title":" Prison Cells After N Days "},{"location":"amazon/#partition-labels","text":"","title":" Partition Labels "},{"location":"amazon/#subtree-with-maximum-average","text":"","title":" Subtree with Maximum Average "},{"location":"google/","text":"Working on it...","title":"Google"},{"location":"google/#working-on-it","text":"","title":"Working on it..."},{"location":"problems/","text":"Binary Tree Level Order Traversal Solution # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def levelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" result = [] current_level = [root] if not root: return [] while current_level: result.append([node.val for node in current_level]) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level return result Same Tree Solution # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def isSameTree(self, p, q): \"\"\" :type p: TreeNode :type q: TreeNode :rtype: bool \"\"\" if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)","title":"Problems"},{"location":"problems/#binary-tree-level-order-traversal","text":"Solution # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def levelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" result = [] current_level = [root] if not root: return [] while current_level: result.append([node.val for node in current_level]) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level return result","title":"  Binary Tree Level Order Traversal "},{"location":"problems/#same-tree","text":"Solution # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def isSameTree(self, p, q): \"\"\" :type p: TreeNode :type q: TreeNode :rtype: bool \"\"\" if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)","title":"  Same Tree "}]}